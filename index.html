<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>ğŸ„ Gesture Christmas Tree</title>

<!-- ===== æ ·å¼ ===== -->
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: radial-gradient(circle at top, #1b3a2a, #050807);
  font-family: system-ui;
  color: #e6c27a;
}

/* UI */
#ui {
  position: fixed;
  top: 14px;
  left: 14px;
  z-index: 10;
}

#ui input {
  background: rgba(10,20,15,.8);
  color: #e6c27a;
  border: 1px solid #e6c27a55;
  padding: 6px;
}

#hint {
  margin-top: 6px;
  font-size: 12px;
  opacity: .8;
}

canvas {
  display: block;
}
</style>
</head>

<body>
<div id="ui">
  <input type="file" id="upload" accept="image/*" multiple />
  <div id="hint">
    âœŠ åˆæ‹¢ ï½œ ğŸ–ï¸ æ•£å¼€ ï½œ ğŸ”„ æ—‹è½¬ ï½œ ğŸ¤ æŠ“å–ç…§ç‰‡
  </div>
</div>

<canvas id="c"></canvas>

<!-- ===== Three.js ===== -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<!-- ===== MediaPipe Hands ===== -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =========================================================
   1. Three.js åŸºç¡€åœºæ™¯
========================================================= */
const canvas = document.getElementById('c');
const scene = new THREE.Scene();

scene.fog = new THREE.Fog(0x050807, 8, 30);

const camera = new THREE.PerspectiveCamera(
  60, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.set(0, 2.5, 8);

const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputColorSpace = THREE.SRGBColorSpace;

/* å…‰ç…§ï¼ˆç”µå½±æ„Ÿï¼‰ */
scene.add(new THREE.AmbientLight(0x664400, 0.6));

const keyLight = new THREE.PointLight(0xffd27d, 2, 30);
keyLight.position.set(0, 6, 4);
scene.add(keyLight);

/* =========================================================
   2. çŠ¶æ€æœºå®šä¹‰
========================================================= */
const STATE = {
  CONE: 'cone',        // åˆæ‹¢
  SCATTER: 'scatter',  // æ•£å¼€
  PHOTO: 'photo'       // ç…§ç‰‡æ”¾å¤§
};
let currentState = STATE.CONE;

/* =========================================================
   3. åœ£è¯æ ‘ Instanced ç²’å­
========================================================= */
const COUNT = 800;
const dummy = new THREE.Object3D();

const geo = new THREE.SphereGeometry(0.06, 8, 8);
const mat = new THREE.MeshStandardMaterial({
  color: 0xe6c27a,
  roughness: 0.35,
  metalness: 0.8,
  emissive: 0x332200
});

const instanced = new THREE.InstancedMesh(geo, mat, COUNT);
scene.add(instanced);

const coneTargets = [];
const scatterTargets = [];

for (let i = 0; i < COUNT; i++) {
  // åœ£è¯æ ‘é”¥ä½“åˆ†å¸ƒ
  const h = Math.random();
  const r = (1 - h) * 1.6 * Math.random();
  const a = Math.random() * Math.PI * 2;

  coneTargets.push(new THREE.Vector3(
    Math.cos(a) * r,
    h * 3,
    Math.sin(a) * r
  ));

  scatterTargets.push(new THREE.Vector3(
    (Math.random() - .5) * 10,
    (Math.random() - .5) * 6,
    (Math.random() - .5) * 10
  ));
}

/* =========================================================
   4. ç…§ç‰‡äº‘
========================================================= */
const photoGroup = new THREE.Group();
scene.add(photoGroup);

const photos = [];

function addPhoto(texture) {
  const mat = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true
  });

  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(1, 1),
    mat
  );

  mesh.position.copy(
    scatterTargets[Math.floor(Math.random() * scatterTargets.length)]
  );
  mesh.scale.setScalar(0.8);

  photoGroup.add(mesh);
  photos.push(mesh);
}

/* =========================================================
   5. æ‰‹åŠ¿è¯†åˆ«ï¼ˆç®€åŒ–ç‰ˆé€»è¾‘ï¼‰
========================================================= */
let handState = 'unknown';

function analyzeHand(landmarks) {
  const palm = landmarks[0];
  const tip = landmarks[8]; // é£ŸæŒ‡

  const dist = Math.hypot(
    palm.x - tip.x,
    palm.y - tip.y
  );

  if (dist < 0.1) return 'fist';
  if (dist > 0.25) return 'open';
  return 'pinch';
}

/* =========================================================
   6. MediaPipe åˆå§‹åŒ–
========================================================= */
const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (!res.multiHandLandmarks?.length) return;

  const s = analyzeHand(res.multiHandLandmarks[0]);

  if (s !== handState) {
    handState = s;

    if (s === 'fist') currentState = STATE.CONE;
    if (s === 'open') currentState = STATE.SCATTER;
    if (s === 'pinch') currentState = STATE.PHOTO;
  }
});

/* æ‘„åƒå¤´ */
const video = document.createElement('video');
const cam = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
cam.start();

/* =========================================================
   7. åŠ¨ç”»å¾ªç¯
========================================================= */
function animate() {
  requestAnimationFrame(animate);

  for (let i = 0; i < COUNT; i++) {
    const target =
      currentState === STATE.CONE
        ? coneTargets[i]
        : scatterTargets[i];

    instanced.getMatrixAt(i, dummy.matrix);
    dummy.position.lerp(target, 0.05);
    dummy.updateMatrix();
    instanced.setMatrixAt(i, dummy.matrix);
  }
  instanced.instanceMatrix.needsUpdate = true;

  renderer.render(scene, camera);
}
animate();

/* =========================================================
   8. ç…§ç‰‡ä¸Šä¼ 
========================================================= */
document.getElementById('upload').addEventListener('change', e => {
  [...e.target.files].forEach(f => {
    const url = URL.createObjectURL(f);
    new THREE.TextureLoader().load(url, t => {
      t.colorSpace = THREE.SRGBColorSpace;
      addPhoto(t);
    });
  });
});

/* =========================================================
   9. Resize
========================================================= */
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
