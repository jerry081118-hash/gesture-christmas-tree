<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D Gesture Christmas Tree - MediaPipe & Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px;
            border-radius: 12px; overflow: hidden; border: 2px solid rgba(212, 175, 55, 0.5);
            transform: scaleX(-1); /* é•œåƒè§†é¢‘ */
            background: #000;
        }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: #D4AF37;
            pointer-events: none; text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
        }
        .upload-btn {
            position: absolute; bottom: 30px; left: 30px;
            padding: 12px 24px; background: #8B0000; color: white;
            border: 1px solid #D4AF37; border-radius: 4px; cursor: pointer;
            pointer-events: auto; transition: 0.3s;
        }
        .upload-btn:hover { background: #D4AF37; color: #8B0000; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #D4AF37; font-size: 24px; text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰ç³»ç»Ÿä¸ 3D å¼•æ“...</div>
<div id="container"></div>
<div id="video-container">
    <video id="input_video" style="width: 100%; height: 100%; object-fit: cover;"></video>
</div>
<div id="ui-layer">
    <h1>Golden Christmas 2024</h1>
    <p>æ‰‹åŠ¿è¯´æ˜ï¼š<br>âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘<br>âœ‹ å¼ æ‰‹ï¼šç²’å­æ•£å¼€<br>ğŸ‘Œ æŠ“å–ï¼šæ”¾å¤§ç…§ç‰‡<br>ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’</p>
</div>
<input type="file" id="photo-upload" class="upload-btn" multiple accept="image/*" value="ä¸Šä¼ ç…§ç‰‡äº‘">

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@20.0.0/dist/tween.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/** * åˆ›æ„å‰ç«¯ä¸“å®¶å®ç°æ–¹æ¡ˆ
 * æ ¸å¿ƒé€»è¾‘ï¼š
 * 1. çŠ¶æ€æœºæ§åˆ¶ï¼šCLOSED (åˆæ‹¢), SCATTER (æ•£å¼€), FOCUS (æ”¾å¤§)
 * 2. æ•°å­¦åˆ†å¸ƒï¼šä½¿ç”¨åœ†é”¥èºæ—‹ç®—æ³•è®¡ç®—åœ£è¯æ ‘åæ ‡
 * 3. æ€§èƒ½ä¼˜åŒ–ï¼šInstancedMesh æ¸²æŸ“è£…é¥°ç‰©
 */

let scene, camera, renderer, hands, treeGroup;
let decorativeItems = []; // å­˜å‚¨ InstancedMesh
let photoMeshes = [];
let currentState = 'CLOSED'; // CLOSED, SCATTER, FOCUS
const PARTICLE_COUNT = 500;
const GOLDEN_COLOR = 0xD4AF37;
const RED_COLOR = 0x8B0000;
const MATTE_GREEN = 0x1A3926;

// åˆå§‹åŒ–åœºæ™¯
function initScene() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.05);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 8);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping; // å¢å¼ºç”µå½±æ„Ÿ
    document.getElementById('container').appendChild(renderer.domElement);

    // å…‰å½±è®¾è®¡
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(GOLDEN_COLOR, 2, 20);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    treeGroup = new THREE.Group();
    scene.add(treeGroup);

    createTreeElements();
    window.addEventListener('resize', onWindowResize);
}

// åˆ›å»ºåœ£è¯æ ‘å…ƒç´ 
function createTreeElements() {
    // 1. åŸºç¡€è£…é¥°ç‰© (InstancedMesh æå‡æ€§èƒ½)
    const geometries = [
        new THREE.SphereGeometry(0.1, 16, 16),
        new THREE.BoxGeometry(0.15, 0.15, 0.15),
        new THREE.CylinderGeometry(0.05, 0.05, 0.3) // æ¨¡æ‹Ÿç³–æœæ£
    ];

    geometries.forEach((geo, idx) => {
        const mat = new THREE.MeshStandardMaterial({
            color: idx === 0 ? GOLDEN_COLOR : (idx === 1 ? RED_COLOR : 0xffffff),
            metalness: 0.9,
            roughness: 0.1,
            emissive: idx === 0 ? GOLDEN_COLOR : 0x000000,
            emissiveIntensity: 0.2
        });
        const mesh = new THREE.InstancedMesh(geo, mat, PARTICLE_COUNT);
        
        // åˆå§‹ä½ç½®åˆ†å¸ƒ
        const dummy = new THREE.Object3D();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            setTreePosition(dummy, i);
            mesh.setMatrixAt(i, dummy.matrix);
            // å­˜å‚¨ç›®æ ‡ä½ç½®
            mesh.userData.targetPositions = mesh.userData.targetPositions || [];
            mesh.userData.targetPositions.push(dummy.position.clone());
        }
        treeGroup.add(mesh);
        decorativeItems.push(mesh);
    });
}

// åœ£è¯æ ‘æ•°å­¦æ¨¡å‹ï¼ˆåœ†é”¥ç®—æ³•ï¼‰
function setTreePosition(obj, index) {
    const total = PARTICLE_COUNT;
    const height = 5;
    const ratio = index / total;
    const angle = ratio * Math.PI * 20; // èºæ—‹åº¦
    const radius = (1 - ratio) * 2;
    
    obj.position.set(
        Math.cos(angle) * radius,
        ratio * height - 2,
        Math.sin(angle) * radius
    );
    obj.updateMatrix();
}

// çŠ¶æ€åˆ‡æ¢é€»è¾‘
function transitionState(newState) {
    if (newState === currentState) return;
    currentState = newState;

    decorativeItems.forEach(mesh => {
        const dummy = new THREE.Object3D();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let targetPos = new THREE.Vector3();
            
            if (newState === 'CLOSED') {
                setTreePosition(dummy, i);
                targetPos.copy(dummy.position);
            } else {
                // æ•£å¼€æ€ï¼šéšæœºæ¼‚æµ®
                targetPos.set(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 15
                );
            }

            // ä½¿ç”¨ TWEEN åŠ¨ç”»
            const currentMatrix = new THREE.Matrix4();
            mesh.getMatrixAt(i, currentMatrix);
            const currentPos = new THREE.Vector3().setFromMatrixPosition(currentMatrix);

            new TWEEN.Tween(currentPos)
                .to(targetPos, 1500)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onUpdate(() => {
                    dummy.position.copy(currentPos);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    mesh.instanceMatrix.needsUpdate = true;
                })
                .start();
        }
    });
}

// ç…§ç‰‡ä¸Šä¼ å¤„ç†
document.getElementById('photo-upload').addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    files.forEach((file, i) => {
        const url = URL.createObjectURL(file);
        const texture = new THREE.TextureLoader().load(url);
        const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        const geo = new THREE.PlaneGeometry(1, 1);
        const mesh = new THREE.Mesh(geo, mat);
        
        mesh.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
        treeGroup.add(mesh);
        photoMeshes.push(mesh);
    });
});

// AI æ‰‹åŠ¿è¯†åˆ«é…ç½®
async function initMediaPipe() {
    const videoElement = document.getElementById('input_video');
    
    hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onHandResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();
    document.getElementById('loading').style.display = 'none';
}

function onHandResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // 1. åˆ¤æ–­æ¡æ‹³ (Fist) - æŒ‡å°–é è¿‘æŒå¿ƒ
        const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;
        // 2. åˆ¤æ–­å¼ å¼€ (Open Palm)
        const isOpen = landmarks[8].y < landmarks[6].y && landmarks[12].y < landmarks[10].y;
        
        if (isFist) transitionState('CLOSED');
        else if (isOpen) transitionState('SCATTER');

        // 3. è§†è§’æ§åˆ¶ï¼šåŸºäºæ‰‹æŒä¸­å¿ƒ X åæ ‡æ—‹è½¬
        const handX = landmarks[0].x; 
        treeGroup.rotation.y += (handX - 0.5) * 0.1;

        // 4. æŠ“å–åŠ¨ä½œ (Pinch) ç®€å•åˆ¤å®šï¼šé£ŸæŒ‡å¤§æ‹‡æŒ‡æåˆ
        const dist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
        if (dist < 0.05 && photoMeshes.length > 0) {
            focusPhoto();
        }
    }
}

function focusPhoto() {
    if (currentState === 'FOCUS') return;
    currentState = 'FOCUS';
    const targetPhoto = photoMeshes[0]; // ç¤ºä¾‹ï¼šèšç„¦ç¬¬ä¸€å¼ 
    new TWEEN.Tween(camera.position)
        .to({ z: 4 }, 1000)
        .start();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    
    // è‡ªåŠ¨å¾®æ—‹
    if (currentState === 'CLOSED') {
        treeGroup.rotation.y += 0.005;
    }
    
    renderer.render(scene, camera);
}

// å¯åŠ¨
initScene();
initMediaPipe();
animate();

</script>
</body>
</html>
