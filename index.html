<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Lite Golden Christmas Tree</title>
    <style>
        body { margin: 0; background: #050a0f; overflow: hidden; font-family: sans-serif; }
        #overlay { position: fixed; inset: 0; background: #050a0f; color: gold; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; transition: 0.5s; }
        .bar { width: 200px; height: 2px; background: #222; margin-top: 10px; position: relative; }
        .progress { width: 0%; height: 100%; background: gold; transition: 0.3s; }
        #upload-btn { position: fixed; bottom: 20px; left: 20px; padding: 10px 20px; background: gold; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
        #status-tag { position: fixed; top: 20px; width: 100%; text-align: center; color: rgba(255,215,0,0.7); pointer-events: none; font-size: 14px; }
    </style>
</head>
<body>

<div id="overlay">
    <div>âœ¨ åœ£è¯å¹»å¢ƒåˆå§‹åŒ–ä¸­...</div>
    <div class="bar"><div class="progress" id="pg"></div></div>
</div>

<div id="status-tag">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–...</div>
<button id="upload-btn" onclick="document.getElementById('f').click()">ğŸ“· ä¸Šä¼ è®°å¿†</button>
<input type="file" id="f" hidden multiple accept="image/*">
<video id="v" style="display:none" playsinline></video>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { GSAP } from 'https://esm.sh/gsap';

    let scene, camera, renderer, tree, particles, snow;
    let isExploded = false;
    const pg = document.getElementById('pg');

    // --- 1. æç®€åœºæ™¯åˆå§‹åŒ– ---
    function initBase() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050a0f);
        scene.fog = new THREE.Fog(0x050a0f, 20, 60);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 30);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ ç‡æå‡æ€§èƒ½
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffd700, 500, 100);
        light.position.set(0, 10, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        createTree();
        createSnow();
        pg.style.width = '40%';
        
        animate();
        loadMediaPipe();
    }

    // --- 2. ä¼˜åŒ–ç²’å­åœ£è¯æ ‘ ---
    function createTree() {
        tree = new THREE.Group();
        const count = 600; // å‡é‡ä½†ä¿æŒå½¢æ€
        const geom = new THREE.TetrahedronGeometry(0.2); // æœ€ç®€å•çš„å‡ ä½•ä½“
        const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 });
        
        particles = new THREE.InstancedMesh(geom, mat, count);
        const dummy = new THREE.Object3D();
        
        for (let i = 0; i < count; i++) {
            const t = i / count;
            const angle = i * 0.3;
            const r = (1 - t) * 7;
            dummy.position.set(Math.cos(angle)*r, t*18 - 9, Math.sin(angle)*r);
            dummy.rotation.set(Math.random(), Math.random(), 0);
            dummy.updateMatrix();
            particles.setMatrixAt(i, dummy.matrix);
        }
        tree.add(particles);
        scene.add(tree);
    }

    function createSnow() {
        const geom = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*100, Math.random()*50, (Math.random()-0.5)*100);
        geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        snow = new THREE.Points(geom, new THREE.PointsMaterial({color: 0xffffff, size: 0.1}));
        scene.add(snow);
    }

    // --- 3. å¼‚æ­¥åŠ è½½æ‰‹åŠ¿åº“ ---
    async function loadMediaPipe() {
        try {
            const scripts = [
                'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
                'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js'
            ];
            for(const src of scripts) {
                await new Promise(resolve => {
                    const s = document.createElement('script');
                    s.src = src; s.onload = resolve;
                    document.head.appendChild(s);
                });
            }
            pg.style.width = '100%';
            setTimeout(() => document.getElementById('overlay').style.opacity = '0', 500);
            setTimeout(() => document.getElementById('overlay').remove(), 1000);
            startTracking();
        } catch (e) {
            document.getElementById('status-tag').innerText = "åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°";
        }
    }

    function startTracking() {
        const hands = new window.Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6 });
        
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                const lm = results.multiHandLandmarks[0];
                const isFist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y) < 0.2;
                
                if (isFist && isExploded) toggle(false);
                if (!isFist && !isExploded) toggle(true);

                // ç›¸æœºè·Ÿéšæ—‹è½¬
                camera.position.x += ((lm[9].x - 0.5) * -30 - camera.position.x) * 0.05;
                camera.lookAt(0, 0, 0);
                document.getElementById('status-tag').innerText = isFist ? "âœŠ æ¡æ‹³ï¼šèšåˆä¸­" : "ğŸ–ï¸ å¼ å¼€ï¼šç»½æ”¾ä¸­";
            }
        });

        const video = document.getElementById('v');
        const cameraFeed = new window.Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: 480, height: 360
        });
        cameraFeed.start();
    }

    function toggle(explode) {
        isExploded = explode;
        const dummy = new THREE.Object3D();
        for (let i = 0; i < 600; i++) {
            let tx, ty, tz;
            if (!explode) {
                const t = i / 600;
                const r = (1 - t) * 7;
                tx = Math.cos(i * 0.3)*r; ty = t * 18 - 9; tz = Math.sin(i * 0.3)*r;
            } else {
                tx = (Math.random()-0.5)*50; ty = (Math.random()-0.5)*40; tz = (Math.random()-0.5)*50;
            }
            // ç®€å•åŠ¨ç”»ä»¥èŠ‚çœæ€§èƒ½
            gsap.to(dummy.position, {
                x: tx, y: ty, z: tz, duration: 1.5, ease: "power2.out",
                onUpdate: () => {
                    dummy.updateMatrix();
                    particles.setMatrixAt(i, dummy.matrix);
                    particles.instanceMatrix.needsUpdate = true;
                }
            });
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!isExploded) tree.rotation.y += 0.01;
        snow.position.y -= 0.03;
        if(snow.position.y < -20) snow.position.y = 20;
        renderer.render(scene, camera);
    }

    // ç›‘å¬çª—å£ç¼©æ”¾
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initBase();
</script>
</body>
</html>
