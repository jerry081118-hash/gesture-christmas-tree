<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Cinematic Christmas Â· AI Vision</title>
    <style>
        :root { --gold: #D4AF37; --red: #B22222; }
        body { margin: 0; overflow: hidden; background: #000; font-family: "Microsoft YaHei", sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* å¯åŠ¨ UI */
        #start-overlay {
            position: fixed; inset: 0; z-index: 1000;
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .glass-card {
            background: rgba(255,255,255,0.05); backdrop-filter: blur(15px);
            padding: 3rem; border-radius: 2rem; border: 1px solid rgba(212,175,55,0.3);
            text-align: center; color: var(--gold);
        }
        #enter-btn {
            margin-top: 2rem; padding: 12px 50px; border-radius: 30px; border: none;
            background: linear-gradient(135deg, var(--gold), #8B6B23);
            font-weight: bold; cursor: pointer; opacity: 0.3; pointer-events: none;
        }
        #enter-btn.active { opacity: 1; pointer-events: auto; }

        /* æ“ä½œæç¤º */
        .controls-panel {
            position: absolute; bottom: 30px; left: 30px; color: white;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 12px;
            border-left: 4px solid var(--gold); font-size: 14px; z-index: 50;
        }
        #video-preview {
            position: absolute; top: 20px; right: 20px; width: 180px; height: 135px;
            border-radius: 10px; border: 2px solid var(--gold); transform: scaleX(-1);
        }
        #photo-input { position: absolute; bottom: 30px; right: 30px; z-index: 100; display: none; }
        .upload-label {
            position: absolute; bottom: 30px; right: 30px; background: var(--red);
            color: white; padding: 10px 20px; border-radius: 20px; cursor: pointer;
        }
    </style>
</head>
<body>

<div id="start-overlay">
    <div class="glass-card">
        <h1 style="letter-spacing: 8px;">THE GOLDEN GLOW</h1>
        <p>ç”µå½±çº§ AI æ‰‹åŠ¿äº¤äº’åœ£è¯æ ‘</p>
        <div style="width:200px; height:2px; background:rgba(212,175,55,0.2); margin:20px auto;">
            <div id="bar" style="width:0%; height:100%; background:var(--gold); transition:0.3s;"></div>
        </div>
        <button id="enter-btn">è¿›å…¥è‰ºæœ¯ç©ºé—´</button>
    </div>
</div>

<div id="container"></div>
<video id="video-preview" playsinline></video>

<div class="controls-panel">
    âœŠ <b>æ¡æ‹³</b>ï¼šé‡æ„åœ£è¯æ ‘ (åˆæ‹¢æ€)<br>
    ğŸ–ï¸ <b>å¼ æ‰‹</b>ï¼šæ˜Ÿè¾°æ•£è½ (æ•£å¼€æ€)<br>
    ğŸ‘Œ <b>æåˆ</b>ï¼šæŠ“ä½å¹¶æ”¾å¤§ç…§ç‰‡<br>
    ğŸ”„ <b>ç§»åŠ¨</b>ï¼šæ—‹è½¬ç”µå½±é•œå¤´
</div>

<label class="upload-label" for="photo-input">ä¸Šä¼ ç…§ç‰‡äº‘</label>
<input type="file" id="photo-input" multiple accept="image/*">

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@20.0.0/dist/tween.module.js';

    let scene, camera, renderer, composer;
    let elements = []; // å­˜å‚¨æ‰€æœ‰å‡ ä½•ä½“
    let photos = [];   // å­˜å‚¨ä¸Šä¼ çš„ç…§ç‰‡
    let currentState = 'CLOSED'; // CLOSED, SCATTER, FOCUS
    let focusedPhoto = null;

    const COLORS = {
        matteGreen: 0x1A3926,
        metallicGold: 0xD4AF37,
        crimson: 0xB22222,
        warmWhite: 0xFFF4E0
    };

    // 1. åˆå§‹åŒ–åœºæ™¯
    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 15);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('container').appendChild(renderer.domElement);

        // ç¯å…‰å¸ƒç½®
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const pointLight = new THREE.PointLight(COLORS.metallicGold, 20, 50);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // åæœŸè¾‰å…‰
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.8;
        
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        createTreeElements();
        window.addEventListener('resize', onResize);
    }

    // 2. åˆ›å»ºå¤šå…ƒåŒ–åœ£è¯æ ‘å…ƒç´ 
    function createTreeElements() {
        const geometries = [
            new THREE.SphereGeometry(0.15, 16, 16), // çƒ
            new THREE.BoxGeometry(0.2, 0.2, 0.2),   // ç«‹æ–¹ä½“
            new THREE.CylinderGeometry(0.05, 0.05, 0.4) // ç³–æœæ£ç®€åŒ–ç‰ˆ
        ];

        const materials = [
            new THREE.MeshStandardMaterial({ color: COLORS.matteGreen, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: COLORS.metallicGold, metalness: 1, roughness: 0.2 }),
            new THREE.MeshStandardMaterial({ color: COLORS.crimson, roughness: 0.5 })
        ];

        for (let i = 0; i < 400; i++) {
            const geo = geometries[Math.floor(Math.random() * geometries.length)];
            const mat = materials[Math.floor(Math.random() * materials.length)];
            const mesh = new THREE.Mesh(geo, mat);
            
            // è®¡ç®—åˆæ‹¢æ€ä½ç½®ï¼ˆåœ†é”¥ä½“ï¼‰
            const t = i / 400;
            const angle = t * Math.PI * 20;
            const radius = (1 - t) * 5;
            mesh.userData.closedPos = new THREE.Vector3(
                Math.cos(angle) * radius,
                t * 12 - 6,
                Math.sin(angle) * radius
            );
            
            // éšæœºæ•£å¼€ä½ç½®
            mesh.userData.scatterPos = new THREE.Vector3(
                (Math.random()-0.5) * 25,
                (Math.random()-0.5) * 20,
                (Math.random()-0.5) * 25
            );

            mesh.position.copy(mesh.userData.closedPos);
            scene.add(mesh);
            elements.push(mesh);
        }
    }

    // 3. çŠ¶æ€åˆ‡æ¢æ ¸å¿ƒé€»è¾‘
    function switchState(newState) {
        if (newState === currentState) return;
        currentState = newState;

        elements.forEach((mesh) => {
            const target = (newState === 'CLOSED') ? mesh.userData.closedPos : mesh.userData.scatterPos;
            new TWEEN.Tween(mesh.position)
                .to({ x: target.x, y: target.y, z: target.z }, 1500)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();
            
            new TWEEN.Tween(mesh.rotation)
                .to({ x: Math.random()*Math.PI, y: Math.random()*Math.PI }, 1500)
                .start();
        });

        // å¦‚æœé€€å‡ºç…§ç‰‡æ¨¡å¼
        if (newState !== 'FOCUS' && focusedPhoto) {
            new TWEEN.Tween(focusedPhoto.position).to({ z: focusedPhoto.userData.scatterPos.z }, 1000).start();
            new TWEEN.Tween(focusedPhoto.scale).to({ x: 1, y: 1 }, 1000).start();
            focusedPhoto = null;
        }
    }

    // 4. ç…§ç‰‡å¤„ç†é€»è¾‘
    document.getElementById('photo-input').addEventListener('change', (e) => {
        const files = Array.from(e.target.files);
        files.forEach((file) => {
            const url = URL.createObjectURL(file);
            new THREE.TextureLoader().load(url, (tex) => {
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), mat);
                
                mesh.userData.closedPos = new THREE.Vector3((Math.random()-0.5)*2, Math.random()*5, (Math.random()-0.5)*2);
                mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*15, (Math.random()-0.5)*15);
                
                mesh.position.copy(mesh.userData.closedPos);
                scene.add(mesh);
                photos.push(mesh);
                elements.push(mesh); // ç…§ç‰‡ä¹Ÿä½œä¸ºä¸€ç§å…ƒç´ å‚ä¸æ•£å¼€
            });
        });
    });

    // 5. AI æ‰‹åŠ¿æ§åˆ¶
    async function setupAI() {
        const video = document.getElementById('video-preview');
        const hands = new window.Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

        hands.onResults(res => {
            if (!res.multiHandLandmarks.length) return;
            const pts = res.multiHandLandmarks[0];

            // é€»è¾‘åˆ¤å®š
            const isFist = pts[8].y > pts[6].y && pts[12].y > pts[10].y;
            const isOpen = pts[8].y < pts[5].y && pts[20].y < pts[17].y;
            const isPinch = Math.hypot(pts[8].x - pts[4].x, pts[8].y - pts[4].y) < 0.05;

            if (isPinch && photos.length > 0) {
                switchState('FOCUS');
                if (!focusedPhoto) {
                    focusedPhoto = photos[Math.floor(Math.random() * photos.length)];
                    new TWEEN.Tween(focusedPhoto.position).to({ x: 0, y: 0, z: 8 }, 1000).start();
                    new TWEEN.Tween(focusedPhoto.scale).to({ x: 2, y: 2 }, 1000).start();
                }
            } else if (isFist) {
                switchState('CLOSED');
            } else if (isOpen) {
                switchState('SCATTER');
            }

            // æ—‹è½¬è§†è§’
            const targetRot = (pts[0].x - 0.5) * 1.5;
            camera.position.x += (targetRot * 10 - camera.position.x) * 0.05;
            camera.lookAt(0, 0, 0);
        });

        const cam = new window.Camera(video, { onFrame: async () => await hands.send({ image: video }) });
        cam.start();
        document.getElementById('bar').style.width = '100%';
        document.getElementById('enter-btn').classList.add('active');
    }

    // å¯åŠ¨æµç¨‹
    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);
        if (currentState === 'CLOSED') {
            scene.rotation.y += 0.005;
        } else {
            scene.rotation.y += 0.001;
        }
        composer.render();
    }

    const loadScript = src => new Promise(res => { const s = document.createElement('script'); s.src = src; s.onload = res; document.head.append(s); });
    init();
    animate();
    Promise.all([
        loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"),
        loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js")
    ]).then(setupAI);

    function onResize() {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    document.getElementById('enter-btn').onclick = () => {
        document.getElementById('start-overlay').style.opacity = '0';
        setTimeout(() => document.getElementById('start-overlay').remove(), 800);
    };

</script>
</body>
</html>
