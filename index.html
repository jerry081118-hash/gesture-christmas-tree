<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Golden Glow Christmas Tree - AI Vision</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'STSong', 'SimSun', serif; }
        #container { width: 100vw; height: 100vh; }
        #video-container {
            position: absolute; top: 20px; right: 20px; width: 200px; height: 150px;
            border-radius: 10px; overflow: hidden; border: 1px solid rgba(255,215,0,0.3);
            transform: scaleX(-1); background: #000; z-index: 10;
        }
        #ui-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: none; z-index: 5;
        }
        .merry-christmas {
            font-size: 80px; color: #D4AF37; margin: 0;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.8);
            font-style: italic; opacity: 0.9;
        }
        .controls-hint {
            position: absolute; top: 20px; left: 20px; color: #fff; background: rgba(0,0,0,0.5);
            padding: 15px; border-radius: 8px; border-left: 4px solid #D4AF37;
        }
        #photo-upload {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(139, 0, 0, 0.8); color: #ffd700; border: 1px solid #ffd700;
            padding: 10px 20px; cursor: pointer; border-radius: 20px;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div id="video-container"><video id="input_video" style="width:100%; height:100%; object-fit:cover;"></video></div>

<div id="ui-text">
    <h1 class="merry-christmas">Merry Christmas</h1>
    <p style="color: #D4AF37; letter-spacing: 5px;">çœ‹éšç€æˆ‘çš„æ‰‹åŠ¿çš„å˜æ¢</p>
</div>

<div class="controls-hint">
    ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼šæ•£å¼€æ˜Ÿè¾°<br>âœŠ æ¡ç´§æ‹³å¤´ï¼šèšåˆåœ£è¯æ ‘<br>ğŸ‘† æåˆæ‰‹æŒ‡ï¼šèšç„¦ç…§ç‰‡<br>ğŸ”„ ç§»åŠ¨æ‰‹éƒ¨ï¼šæ—‹è½¬è§†è§’
</div>

<input type="file" id="photo-upload" multiple accept="image/*" title="ç‚¹å‡»ä¸Šä¼ æ‚¨çš„ç…§ç‰‡äº‘">

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@20.0.0/dist/tween.module.js';

    let scene, camera, renderer, composer, treeParticles, star;
    let photoGroup = new THREE.Group();
    let currentState = 'CLOSED'; // CLOSED, SCATTER
    const COUNT = 3000; // å¢åŠ ç²’å­æ•°é‡ä»¥è·å¾—ç¹æ˜Ÿæ„Ÿ

    // 1. åˆå§‹åŒ–åœºæ™¯
    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // åæœŸå¤„ç†ï¼šè¾‰å…‰æ•ˆæœï¼ˆBloomï¼‰
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // å…‰æ™•å¼ºåº¦
        bloomPass.radius = 1.0;
        
        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        createStars();
        createTopStar();
        scene.add(photoGroup);
        
        window.addEventListener('resize', onResize);
    }

    // 2. åˆ›å»ºç¹æ˜Ÿç²’å­ï¼ˆåœ£è¯æ ‘å½¢æ€ï¼‰
    function createStars() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const colors = new Float32Array(COUNT * 3);
        const sizes = new Float32Array(COUNT);

        const colorGold = new THREE.Color(0xD4AF37);
        const colorGreen = new THREE.Color(0x1A3926);

        for (let i = 0; i < COUNT; i++) {
            // åˆå§‹è®¡ç®—æ ‘çŠ¶åˆ†å¸ƒ
            const pos = getTreePos(i);
            positions[i * 3] = pos.x;
            positions[i * 3 + 1] = pos.y;
            positions[i * 3 + 2] = pos.z;

            // æ··åˆé‡‘ç»¿ä¸¤è‰²
            const mixedColor = i % 3 === 0 ? colorGold : colorGreen;
            colors[i * 3] = mixedColor.r;
            colors[i * 3 + 1] = mixedColor.g;
            colors[i * 3 + 2] = mixedColor.b;

            sizes[i] = Math.random() * 0.15 + 0.05;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        treeParticles = new THREE.Points(geometry, material);
        scene.add(treeParticles);
    }

    // åœ£è¯æ ‘ç®—æ³•ï¼šåœ†é”¥+éšæœºæŠ–åŠ¨
    function getTreePos(i) {
        const ratio = i / COUNT;
        const angle = ratio * Math.PI * 40;
        const radius = (1 - ratio) * 3.5;
        const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.5;
        const y = ratio * 8 - 4;
        const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.5;
        return new THREE.Vector3(x, y, z);
    }

    // æ ‘é¡¶æ˜Ÿ
    function createTopStar() {
        const shape = new THREE.SphereGeometry(0.3, 16, 16);
        const mat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        star = new THREE.Mesh(shape, mat);
        star.position.y = 4.2;
        scene.add(star);
    }

    // 3. çŠ¶æ€åˆ‡æ¢åŠ¨ç”»
    function transformParticles(mode) {
        if (mode === currentState) return;
        currentState = mode;

        const positions = treeParticles.geometry.attributes.position.array;
        
        for (let i = 0; i < COUNT; i++) {
            let target = new THREE.Vector3();
            if (mode === 'CLOSED') {
                target = getTreePos(i);
            } else {
                target.set((Math.random()-0.5)*20, (Math.random()-0.5)*15, (Math.random()-0.5)*20);
            }

            const currentPos = { 
                x: positions[i*3], 
                y: positions[i*3+1], 
                z: positions[i*3+2] 
            };

            new TWEEN.Tween(currentPos)
                .to({ x: target.x, y: target.y, z: target.z }, 2000)
                .easing(TWEEN.Easing.Exponential.InOut)
                .onUpdate(() => {
                    positions[i*3] = currentPos.x;
                    positions[i*3+1] = currentPos.y;
                    positions[i*3+2] = currentPos.z;
                    treeParticles.geometry.attributes.position.needsUpdate = true;
                })
                .start();
        }
    }

    // 4. æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ (åŸºäºå›¾ç‰‡ä¸­çš„è§†è§‰éœ€æ±‚)
    async function setupAI() {
        const videoElement = document.getElementById('input_video');
        const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
        hands.onResults((results) => {
            if (!results.multiHandLandmarks.length) return;
            const pts = results.multiHandLandmarks[0];

            // ç®€å•çš„æ‰‹åŠ¿åˆ¤å®šé€»è¾‘
            const isFist = pts[8].y > pts[6].y && pts[12].y > pts[10].y;
            const isOpen = pts[8].y < pts[5].y && pts[12].y < pts[9].y;

            if (isFist) transformParticles('CLOSED');
            else if (isOpen) transformParticles('SCATTER');

            // æ—‹è½¬ï¼šæ ¹æ®æ‰‹æŒä¸­å¿ƒ X ä½ç½®
            treeParticles.rotation.y += (pts[0].x - 0.5) * 0.1;
            photoGroup.rotation.y += (pts[0].x - 0.5) * 0.1;
        });

        const cameraAI = new window.Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });
        cameraAI.start();
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);
        
        // æ ‘é¡¶æ˜Ÿè‡ªè½¬å’Œå¾®å…‰
        star.rotation.y += 0.05;
        star.scale.setScalar(1 + Math.sin(time * 0.005) * 0.2);

        composer.render();
    }

    // å¯åŠ¨
    init();
    // åŠ¨æ€åŠ è½½ MediaPipe è„šæœ¬
    const script1 = document.createElement('script');
    script1.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
    const script2 = document.createElement('script');
    script2.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
    script2.onload = setupAI;
    document.head.appendChild(script1);
    document.head.appendChild(script2);

    animate();

    // ç…§ç‰‡ä¸Šä¼ é€»è¾‘
    document.getElementById('photo-upload').addEventListener('change', (e) => {
        const files = Array.from(e.target.files);
        files.forEach((file) => {
            const url = URL.createObjectURL(file);
            new THREE.TextureLoader().load(url, (tex) => {
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), mat);
                mesh.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*8, (Math.random()-0.5)*5);
                photoGroup.add(mesh);
            });
        });
    });

</script>
</body>
</html>
